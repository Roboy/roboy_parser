# Math lexicon

(rule $Expr ($PHRASE) (NumberFn))
(rule $Operator (plus) (ConstantFn (lambda y (lambda x (call + (var x) (var y))))))
(rule $Operator (minus) (ConstantFn (lambda y (lambda x (call - (var x) (var y))))))
(rule $Operator (times) (ConstantFn (lambda y (lambda x (call * (var x) (var y))))))
(rule $Operator (divided by) (ConstantFn (lambda y (lambda x (call / (var x) (var y))))))
(rule $Operator (multiplied by) (ConstantFn (lambda y (lambda x (call * (var x) (var y))))))
(rule $Operator (divided by) (ConstantFn (lambda y (lambda x (call / (var x) (var y))))))
(rule $Operator (+) (ConstantFn (lambda y (lambda x (call + (var x) (var y))))))
(rule $Operator (-) (ConstantFn (lambda y (lambda x (call - (var x) (var y))))))
(rule $Operator (*) (ConstantFn (lambda y (lambda x (call * (var x) (var y))))))
(rule $Operator (/) (ConstantFn (lambda y (lambda x (call / (var x) (var y))))))
(rule $Operator (($PHRASE optional) power of) (ConstantFn (lambda y (lambda x (call java.lang.Math.pow (var x) (var y))))))
(rule $Function (cosine of) (ConstantFn (lambda x (call java.lang.Math.cos (var x)))))
(rule $Function (sine of) (ConstantFn (lambda x (call java.lang.Math.sin (var x)))))
(rule $Function (absolute (value optional) of) (ConstantFn (lambda x (call java.lang.Math.abs (var x)))))
(rule $Function (square (root optional) of) (ConstantFn (lambda x (call java.lang.Math.sqrt (var x)))))
(rule $Conversion (in degrees) (ConstantFn (lambda x (call java.lang.Math.toDegrees (var x)))))
(rule $Conversion (in radians) (ConstantFn (lambda x (call java.lang.Math.toRadians (var x)))))
(rule $Partial ($Operator $Expr) (JoinFn forward))
(rule $Expr ($Expr $Partial) (JoinFn backward))
(rule $Expr ($Function $Expr) (JoinFn forward))
(rule $Expr ($Expr $Conversion) (JoinFn backward))

(rule $ROOT ((what optional) (is optional) $Expr (? optional)) (IdentityFn))
(rule $ROOT ((how optional) (much optional) (is optional) $Expr (? optional)) (IdentityFn))
